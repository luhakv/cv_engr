# -*- coding: utf-8 -*-
"""Копия блокнота "skimage_etalon.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11g6z2aPgzVds5f5x-LJKk6UQj2uju_eQ

## Что можно показать в skimage?
"""



"""Официальная страница skiimage с примерами:
https://scikit-image.org/docs/stable/auto_examples/ 
Некоторые из них я покажу вам здесь

### Цветовые модели и работа с цветом

Так же, как в OpenCV, можно переходить к разным цветовым моделям.
"""

import matplotlib.pyplot as plt

from skimage import data
from skimage.color import rgb2gray

original = data.astronaut()
grayscale = rgb2gray(original)

plt.subplot(121)
plt.imshow(original)
plt.title("Original")
plt.subplot(122)
plt.imshow(grayscale, cmap=plt.cm.gray)
plt.title("Grayscale")
plt.show()

from skimage.color import rgb2hsv
rgb_img = data.coffee()
hsv_img = rgb2hsv(rgb_img)
hue_img = hsv_img[:, :, 0]
value_img = hsv_img[:, :, 2]

plt.figure(figsize=(15,10))
plt.subplot(131)
plt.imshow(rgb_img)
plt.title("RGB image")
plt.subplot(132)
plt.imshow(hue_img, cmap='hsv')
plt.title("Hue channel")
plt.subplot(133)
plt.imshow(value_img)
plt.title("Value channel")

plt.show()

"""Можно выделить предмет на изображние, поставив threshold на цветовой фон:"""

hue_threshold = 0.04
binary_img = hue_img > hue_threshold

plt.imshow(binary_img)
plt.title("Hue-thresholded image")

plt.show()

import matplotlib.pyplot as plt

from skimage import data
from skimage import exposure
from skimage.exposure import match_histograms

reference = data.coffee()
image = data.chelsea()

matched = match_histograms(image, reference, multichannel=True)


plt.figure(figsize=(15,10))
plt.subplot(131)
plt.imshow(image)
plt.title('Source')
plt.subplot(132)
plt.imshow(reference)
plt.title('Reference')
plt.subplot(133)
plt.imshow(matched)
plt.title('Matched')

plt.show()

"""Тут же можно разделить различные типы тканей на изображении:"""

from skimage import data
from skimage.color import rgb2hed
from matplotlib.colors import LinearSegmentedColormap

# Create an artificial color close to the original one
cmap_hema = LinearSegmentedColormap.from_list('mycmap', ['white', 'navy'])
cmap_dab = LinearSegmentedColormap.from_list('mycmap', ['white',
                                             'saddlebrown'])
cmap_eosin = LinearSegmentedColormap.from_list('mycmap', ['darkviolet',
                                               'white'])

ihc_rgb = data.immunohistochemistry()
ihc_hed = rgb2hed(ihc_rgb)

plt.figure(figsize=(15, 15))
plt.subplot(221)
plt.imshow(ihc_rgb)
plt.title("Original image")

plt.subplot(222)
plt.imshow(ihc_hed[:, :, 0], cmap=cmap_hema)
plt.title("Hematoxylin")

plt.subplot(223)
plt.imshow(ihc_hed[:, :, 1], cmap=cmap_eosin)
plt.title("Eosin")

plt.subplot(224)
plt.imshow(ihc_hed[:, :, 2], cmap=cmap_dab)
plt.title("DAB")


plt.show()

"""## Улучшение контрастности"""

import matplotlib
import matplotlib.pyplot as plt
import numpy as np

from skimage import data, img_as_float
from skimage import exposure


matplotlib.rcParams['font.size'] = 8


img = data.moon()

# Contrast stretching
p2, p98 = np.percentile(img, (2, 98))
img_rescale = exposure.rescale_intensity(img, in_range=(p2, p98))

# Equalization
img_eq = exposure.equalize_hist(img)

# Adaptive Equalization
img_adapteq = exposure.equalize_adapthist(img, clip_limit=0.03)

# Display results
plt.figure(figsize=(20,10))

plt.subplot(141)
plt.imshow(img, cmap=plt.cm.gray)
plt.title('Low contrast image')

plt.subplot(142)
plt.imshow(img_rescale, cmap=plt.cm.gray)
plt.title('Contrast stretching')

plt.subplot(143)
plt.imshow(img_eq, cmap=plt.cm.gray)
plt.title('Histogram equalization')

plt.subplot(144)
plt.imshow(img_adapteq, cmap=plt.cm.gray)
plt.title('Adaptive equalization')

plt.show()

"""## Детектор границ"""

from skimage import feature
edges_dab = feature.canny(ihc_hed[:, :, 2], sigma=0.4)

plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(ihc_hed[:, :, 2], cmap_dab)
plt.title('DAB image')
plt.subplot(122)
plt.imshow(edges_dab, cmap=plt.cm.gray)
plt.title('Edges of DAB')
plt.show()

"""Таким образом можно подготовить датасет для задачи сегментации. Осталось только сохранить изображение с помощью matplotlib."""

plt.imsave('some_dir/mask_image.jpg', edges_dab)

"""# Задание
С помощью Canny edge detector найдите эллипс по цветовому градиенту между красным и белым (задача на погуглить, советую проштудировать галерею skimage). Результатом должна быть маска эллипса на изображении. Подайте ее на вход тестовой функции)
"""

from skimage import data, color, img_as_ubyte
from skimage.feature import canny
from skimage.transform import hough_ellipse
from skimage.draw import ellipse_perimeter

image_rgb = data.coffee()[0:220, 160:420]

plt.imshow(image_rgb)

image_gray = color.rgb2gray(image_rgb)
edges = canny(image_gray, sigma=2.0,
              low_threshold=0.55, high_threshold=0.8)

import numpy as np
result = hough_ellipse(edges, accuracy=20, threshold=250,
                    min_size=100, max_size=120)
result.sort(order='accumulator')
best = list(result[-1])
yc, xc, a, b = [int(round(x)) for x in best[1:5]]
orientation = best[5]
cy, cx = ellipse_perimeter(yc, xc, a, b, orientation)
mask = np.zeros((edges.shape))
mask = color.gray2rgb(img_as_ubyte(mask))
mask[cy, cx] = (250, 0, 0)
mask = color.rgb2gray(img_as_ubyte(mask))
mask[mask>0]=1
print(np.sum((mask == 1) & edges))

"""# Задание 2
Восстановите яркость темного изображения Меган Фокс по референсной картинке
"""

import skimage
from skimage import exposure
from skimage.exposure import match_histograms
import numpy as np


megan = skimage.io.imread('megan.jpeg')
dark_megan =  skimage.io.imread('dark_megan.jpeg')

matched = match_histograms(dark_megan, megan, multichannel=True)
np.sum(np.isclose(matched, megan, atol=0.1))
#сделайте +- 50

