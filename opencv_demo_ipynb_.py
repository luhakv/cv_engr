# -*- coding: utf-8 -*-
"""Копия блокнота "opencv_demo.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mqfEVXzUKK4Ybu8FZBZ4K_tyiTHpPvMC

# OpenCV
Этот ноутбук призван продемонстрировать вам некоторые возможности библиотеки OpenCV. Перед использованием закиньте изображение Лены в Colab.
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np

"""Для начала прочитаем наше изображение."""

img = cv2.imread('/content/Lenna.png')

"""Запринтим изображение, чтобы увидеть, как оно выглядит с точки зрения компьютера:"""

print(img)

"""А теперь, с помощью matplotlib (так удобнее) отрисуем изображение уже в виде изображения:"""

plt.imshow(img)
plt.show()

"""Видим, что изображение какое-то синее. Дело в том, что часто при чтении изображения оно читается как BGR, а не RGB, но это не трудно исправить"""

img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.imshow(img)
plt.show()

"""# Кадрирование
Вот теперь все в порядке, можем начать издеваться над нашей Леной. Начнем с кадрирования изображения. Это очень легко делать, просто используя стандартные срезы матрицы нумпая.
"""

cropped_img = img[600:1900, 500:1500]
plt.imshow(cropped_img)
plt.show()

"""## Изменение размера"""

resized_img = cv2.resize(img, (600, 400), interpolation = cv2.INTER_AREA)
plt.imshow(resized_img)
plt.show()

"""# Рисование прямоугольников"""

output = img.copy()
cv2.rectangle(output, (550, 200), (1500, 1600), (0, 255, 255), 10)
plt.imshow(output)
plt.show()

"""# Текст на изображении"""

output = img.copy()
cv2.putText(output, "Lenna", (500, 1800), cv2.FONT_HERSHEY_SIMPLEX, 15, (30, 105, 210), 40) 
plt.imshow(output)
plt.show()

"""# Градации серого и threshold"""

gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
_, thresholded_img = cv2.threshold(gray_img, 127, 255, 0)
plt.subplot(121)
plt.imshow(gray_img)
plt.subplot(122)
plt.imshow(thresholded_img)
plt.show()

"""Мы столкнулись с проблемой отображения одномерных изображений, надо отдельно указывать цветовую карту. Сделаем это."""

gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
_, thresholded_img = cv2.threshold(gray_img, 127, 255, 0)
plt.subplot(121)
plt.imshow(gray_img, cmap='gray')
plt.subplot(122)
plt.imshow(thresholded_img, cmap='gray')
plt.show()

"""# Фильтры
Теперь можно пройтись по различным фильтрами, они пригодятся вам, когда у вас будут зашумленные изображения
"""

noise = np.random.randint(0, 255, (2048,2048,3)).astype(np.uint8)
noisy_img = cv2.addWeighted(img, 0.7, noise, 0.3, 2.2) # кстати, это способ получить смесь изображений

gblurred_img = cv2.GaussianBlur(noisy_img, (21, 21), 0)
mblurred_img = cv2.medianBlur(noisy_img, 21)
plt.figure(figsize=(15, 5))
plt.subplot(131)
plt.title('Шумная Лена')
plt.imshow(noisy_img)
plt.subplot(132)
plt.title('Сглаженная по Гауссу')
plt.imshow(gblurred_img)
plt.subplot(133)
plt.title('Сглаженная по медиане')
plt.imshow(mblurred_img)
plt.show()

"""# Задание 1
Нужно локализовать на изображении дорожный знак пешеходный переход с помощью цветового порога. Результатом у вас должна получиться маска изображения, на которой хорошо выделен дорожный знак. (Рекомендую перевести изображение в HSV и погуглить функцию inRange). Финальную маску изображения попрошу назвать result_image.
"""

pesh = cv2.imread('peshehod.jpeg')
plt.imshow(pesh) #перепутаны местами каналы, не забудьте))

### PUT YOUR CODE HERE ###

#Введите в поле для ответа число, которое получится после выполнения кода ниже:
print(np.sum(thresh_img[120:250, 120:250])/np.sum(thresh_img))

"""# Задание 2
Сделайте threshold Лены по порогу выше 180.
"""

### PUT YOUR CODE HERE

#Введите число, полученное в результате выполнения кода ниже в строку для ответов
print(np.sum(thresholded_img)/255)

